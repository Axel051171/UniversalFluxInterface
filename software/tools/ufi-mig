#!/usr/bin/env python3
"""
UFI MIG Dumper Integration Tool

This tool provides command-line integration with the MIG Switch Dumper device,
allowing UFI to detect, monitor, and manage dump files from the MIG Dumper.

The MIG Dumper operates in two modes:
1. Standalone Mode: Dumps directly to internal/external SD card
2. PC Mode: Streams data via USB (uses NXDT protocol)

This tool focuses on integrating with the standalone mode output files.

Copyright (c) 2026 UFI Project
SPDX-License-Identifier: GPL-3.0-or-later
"""

import os
import sys
import time
import json
import shutil
import hashlib
import argparse
import subprocess
from pathlib import Path
from dataclasses import dataclass, field
from typing import Optional, List, Dict, Callable
from datetime import datetime
import struct

# ============================================================================
# Constants
# ============================================================================

VERSION = "1.0.0"

# Known MIG Dumper USB identifiers
MIG_USB_IDS = [
    (0x303A, 0x0002, "ESP32-S2 Generic"),
    (0x303A, 0x1001, "ESP32-S2 CDC"),
    # Add actual MIG VID/PID when determined
]

# File patterns
XCI_EXTENSION = ".xci"
CERT_SUFFIX = " (Certificate).bin"
INITDATA_SUFFIX = " (Initial Data).bin"
CARDID_SUFFIX = " (Card ID Set).bin"
CARDUID_SUFFIX = " (Card UID).bin"

# XCI Header constants
XCI_HEADER_MAGIC = b"HEAD"
XCI_PAGE_SIZE = 0x200
XCI_CERT_OFFSET = 0x7000

# ROM Size codes
ROM_SIZES = {
    0xFA: (1, "1 GB"),
    0xF8: (2, "2 GB"),
    0xF0: (4, "4 GB"),
    0xE0: (8, "8 GB"),
    0xE1: (16, "16 GB"),
    0xE2: (32, "32 GB"),
}

# Default paths
UFI_IMAGES_DIR = "/var/lib/ufi/images"
MIG_MOUNT_POINT = "/mnt/mig"

# ============================================================================
# Data Classes
# ============================================================================

@dataclass
class XCIHeader:
    """Nintendo Switch XCI file header structure"""
    signature: bytes = field(default_factory=lambda: b'\x00' * 0x100)
    magic: bytes = field(default_factory=lambda: b'HEAD')
    rom_area_start_page: int = 0
    backup_area_start_page: int = 0xFFFFFFFF
    key_index: int = 0
    rom_size: int = 0
    version: int = 0
    flags: int = 0
    package_id: bytes = field(default_factory=lambda: b'\x00' * 8)
    valid_data_end_page: int = 0
    card_info_iv: bytes = field(default_factory=lambda: b'\x00' * 16)
    partition_fs_header_address: int = 0
    partition_fs_header_size: int = 0
    partition_fs_header_hash: bytes = field(default_factory=lambda: b'\x00' * 32)
    initial_data_hash: bytes = field(default_factory=lambda: b'\x00' * 32)
    
    @classmethod
    def from_bytes(cls, data: bytes) -> 'XCIHeader':
        """Parse XCI header from bytes"""
        if len(data) < 0x200:
            raise ValueError("Data too short for XCI header")
        
        header = cls()
        header.signature = data[0:0x100]
        header.magic = data[0x100:0x104]
        
        if header.magic != XCI_HEADER_MAGIC:
            raise ValueError(f"Invalid XCI magic: {header.magic}")
        
        header.rom_area_start_page = struct.unpack('<I', data[0x104:0x108])[0]
        header.backup_area_start_page = struct.unpack('<I', data[0x108:0x10C])[0]
        header.key_index = data[0x10C]
        header.rom_size = data[0x10D]
        header.version = data[0x10E]
        header.flags = data[0x10F]
        header.package_id = data[0x110:0x118]
        header.valid_data_end_page = struct.unpack('<I', data[0x118:0x11C])[0]
        header.card_info_iv = data[0x120:0x130]
        header.partition_fs_header_address = struct.unpack('<Q', data[0x130:0x138])[0]
        header.partition_fs_header_size = struct.unpack('<Q', data[0x138:0x140])[0]
        header.partition_fs_header_hash = data[0x140:0x160]
        header.initial_data_hash = data[0x160:0x180]
        
        return header
    
    def get_rom_size_gb(self) -> int:
        """Get ROM capacity in GB"""
        return ROM_SIZES.get(self.rom_size, (0, "Unknown"))[0]
    
    def get_rom_size_string(self) -> str:
        """Get ROM capacity as string"""
        return ROM_SIZES.get(self.rom_size, (0, "Unknown"))[1]
    
    def get_data_size(self) -> int:
        """Get actual data size in bytes"""
        return (self.valid_data_end_page + 1) * XCI_PAGE_SIZE
    
    def get_trimmed_size(self) -> int:
        """Get trimmed file size"""
        return self.get_data_size()


@dataclass
class DumpInfo:
    """Information about a dump on the MIG Dumper"""
    path: str
    title: str
    title_id: str = ""
    version: str = ""
    rom_size_gb: int = 0
    file_size: int = 0
    trimmed_size: int = 0
    dump_date: Optional[datetime] = None
    has_certificate: bool = False
    has_initial_data: bool = False
    has_card_id: bool = False
    has_card_uid: bool = False
    xci_path: str = ""
    cert_path: str = ""
    initdata_path: str = ""
    cardid_path: str = ""
    carduid_path: str = ""


@dataclass
class MIGDevice:
    """MIG Dumper device information"""
    device_path: str = ""
    mount_point: str = ""
    volume_label: str = ""
    firmware_version: str = ""
    serial: str = ""
    total_space: int = 0
    free_space: int = 0
    is_mounted: bool = False


# ============================================================================
# MIG Dumper Manager Class
# ============================================================================

class MIGDumperManager:
    """Manager class for MIG Dumper integration"""
    
    def __init__(self, mount_point: str = MIG_MOUNT_POINT):
        self.mount_point = mount_point
        self.device: Optional[MIGDevice] = None
        self._progress_callback: Optional[Callable] = None
    
    def set_progress_callback(self, callback: Callable):
        """Set callback for progress updates"""
        self._progress_callback = callback
    
    def _report_progress(self, current: int, total: int, message: str = ""):
        """Report progress to callback"""
        if self._progress_callback:
            percent = int((current * 100) / total) if total > 0 else 0
            self._progress_callback(current, total, percent, message)
    
    # ========================================================================
    # Device Detection and Management
    # ========================================================================
    
    def detect_device(self) -> Optional[MIGDevice]:
        """Detect MIG Dumper device"""
        
        # Check if already mounted
        if os.path.ismount(self.mount_point):
            return self._get_mounted_device_info()
        
        # Scan for USB devices
        device_path = self._find_mig_usb_device()
        if device_path:
            return MIGDevice(device_path=device_path)
        
        return None
    
    def _find_mig_usb_device(self) -> Optional[str]:
        """Find MIG Dumper USB device path"""
        
        try:
            # Use lsblk to find USB block devices
            result = subprocess.run(
                ['lsblk', '-J', '-o', 'NAME,TRAN,VENDOR,MODEL,SIZE,MOUNTPOINT'],
                capture_output=True, text=True
            )
            
            if result.returncode != 0:
                return None
            
            data = json.loads(result.stdout)
            
            for device in data.get('blockdevices', []):
                # Look for USB devices
                if device.get('tran') == 'usb':
                    # Check for partitions
                    children = device.get('children', [])
                    if children:
                        for part in children:
                            part_name = part.get('name', '')
                            if part_name:
                                return f"/dev/{part_name}"
                    else:
                        # Device without partitions
                        name = device.get('name', '')
                        if name:
                            return f"/dev/{name}"
        
        except (subprocess.SubprocessError, json.JSONDecodeError):
            pass
        
        return None
    
    def _get_mounted_device_info(self) -> MIGDevice:
        """Get info about mounted device"""
        
        device = MIGDevice(
            mount_point=self.mount_point,
            is_mounted=True
        )
        
        # Get filesystem info
        try:
            stat = os.statvfs(self.mount_point)
            device.total_space = stat.f_blocks * stat.f_bsize
            device.free_space = stat.f_bavail * stat.f_bsize
        except OSError:
            pass
        
        # Try to read firmware version
        device.firmware_version = self._read_firmware_version()
        
        self.device = device
        return device
    
    def mount(self, device_path: Optional[str] = None) -> bool:
        """Mount MIG Dumper filesystem"""
        
        if os.path.ismount(self.mount_point):
            print(f"Already mounted at {self.mount_point}")
            self.device = self._get_mounted_device_info()
            return True
        
        if not device_path:
            device_path = self._find_mig_usb_device()
        
        if not device_path:
            print("No MIG Dumper device found")
            return False
        
        # Create mount point
        os.makedirs(self.mount_point, exist_ok=True)
        
        # Try mounting as vfat first, then exfat
        for fstype in ['vfat', 'exfat']:
            try:
                result = subprocess.run(
                    ['mount', '-t', fstype, '-o', 'utf8,umask=0000',
                     device_path, self.mount_point],
                    capture_output=True, text=True
                )
                
                if result.returncode == 0:
                    print(f"Mounted {device_path} at {self.mount_point} ({fstype})")
                    self.device = self._get_mounted_device_info()
                    self.device.device_path = device_path
                    return True
            
            except subprocess.SubprocessError:
                continue
        
        print(f"Failed to mount {device_path}")
        return False
    
    def unmount(self) -> bool:
        """Unmount MIG Dumper filesystem"""
        
        if not os.path.ismount(self.mount_point):
            return True
        
        # Sync first
        subprocess.run(['sync'], capture_output=True)
        
        try:
            result = subprocess.run(
                ['umount', self.mount_point],
                capture_output=True, text=True
            )
            
            if result.returncode == 0:
                print(f"Unmounted {self.mount_point}")
                self.device = None
                return True
            
            # Try lazy unmount
            result = subprocess.run(
                ['umount', '-l', self.mount_point],
                capture_output=True, text=True
            )
            
            return result.returncode == 0
        
        except subprocess.SubprocessError:
            return False
    
    def _read_firmware_version(self) -> str:
        """Read firmware version from device"""
        
        system_path = os.path.join(self.mount_point, "System")
        
        if not os.path.isdir(system_path):
            return "Unknown"
        
        # Look for version marker files
        try:
            for entry in os.listdir(system_path):
                # Version files are typically just numbers like "1.2.3"
                if entry[0].isdigit() and '.' in entry:
                    return entry
        except OSError:
            pass
        
        return "Unknown"
    
    # ========================================================================
    # Dump Discovery and Analysis
    # ========================================================================
    
    def list_dumps(self) -> List[DumpInfo]:
        """List all dumps on the MIG Dumper"""
        
        if not os.path.ismount(self.mount_point):
            return []
        
        dumps = []
        
        try:
            for entry in os.listdir(self.mount_point):
                # Skip system folders
                if entry.startswith('.') or entry == 'System':
                    continue
                
                full_path = os.path.join(self.mount_point, entry)
                
                if os.path.isdir(full_path):
                    # Check for XCI file inside directory
                    dump = self._analyze_dump_folder(full_path, entry)
                    if dump:
                        dumps.append(dump)
                
                elif entry.lower().endswith('.xci'):
                    # Direct XCI file
                    dump = self._analyze_xci_file(full_path)
                    if dump:
                        dumps.append(dump)
        
        except OSError as e:
            print(f"Error listing dumps: {e}")
        
        return dumps
    
    def _analyze_dump_folder(self, folder_path: str, folder_name: str) -> Optional[DumpInfo]:
        """Analyze a dump folder"""
        
        # Look for XCI file
        xci_path = os.path.join(folder_path, f"{folder_name}.xci")
        
        if not os.path.exists(xci_path):
            # Try to find any XCI file
            try:
                for entry in os.listdir(folder_path):
                    if entry.lower().endswith('.xci'):
                        xci_path = os.path.join(folder_path, entry)
                        break
            except OSError:
                return None
        
        if not os.path.exists(xci_path):
            return None
        
        dump = self._analyze_xci_file(xci_path)
        if dump:
            dump.path = folder_path
            
            # Check for additional files
            base_name = os.path.splitext(os.path.basename(xci_path))[0]
            
            cert_path = os.path.join(folder_path, base_name + CERT_SUFFIX)
            if os.path.exists(cert_path):
                dump.has_certificate = True
                dump.cert_path = cert_path
            
            initdata_path = os.path.join(folder_path, base_name + INITDATA_SUFFIX)
            if os.path.exists(initdata_path):
                dump.has_initial_data = True
                dump.initdata_path = initdata_path
            
            cardid_path = os.path.join(folder_path, base_name + CARDID_SUFFIX)
            if os.path.exists(cardid_path):
                dump.has_card_id = True
                dump.cardid_path = cardid_path
            
            carduid_path = os.path.join(folder_path, base_name + CARDUID_SUFFIX)
            if os.path.exists(carduid_path):
                dump.has_card_uid = True
                dump.carduid_path = carduid_path
        
        return dump
    
    def _analyze_xci_file(self, xci_path: str) -> Optional[DumpInfo]:
        """Analyze an XCI file"""
        
        try:
            stat = os.stat(xci_path)
            file_size = stat.st_size
            mtime = datetime.fromtimestamp(stat.st_mtime)
            
            # Read and parse header
            with open(xci_path, 'rb') as f:
                header_data = f.read(0x200)
            
            header = XCIHeader.from_bytes(header_data)
            
            # Extract title from filename
            base_name = os.path.splitext(os.path.basename(xci_path))[0]
            
            # Try to parse title ID from filename (format: "Game Name [titleid]")
            title = base_name
            title_id = ""
            
            if '[' in base_name and ']' in base_name:
                bracket_start = base_name.rfind('[')
                bracket_end = base_name.rfind(']')
                if bracket_end > bracket_start:
                    title_id = base_name[bracket_start+1:bracket_end]
                    title = base_name[:bracket_start].strip()
            
            return DumpInfo(
                path=xci_path,
                title=title,
                title_id=title_id,
                rom_size_gb=header.get_rom_size_gb(),
                file_size=file_size,
                trimmed_size=header.get_trimmed_size(),
                dump_date=mtime,
                xci_path=xci_path
            )
        
        except (OSError, ValueError) as e:
            print(f"Error analyzing {xci_path}: {e}")
            return None
    
    # ========================================================================
    # Copy Operations
    # ========================================================================
    
    def copy_dump(self, dump: DumpInfo, dest_dir: str,
                  include_extras: bool = True) -> bool:
        """Copy a dump to destination directory"""
        
        os.makedirs(dest_dir, exist_ok=True)
        
        files_to_copy = [(dump.xci_path, os.path.basename(dump.xci_path))]
        
        if include_extras:
            if dump.has_certificate:
                files_to_copy.append((dump.cert_path, os.path.basename(dump.cert_path)))
            if dump.has_initial_data:
                files_to_copy.append((dump.initdata_path, os.path.basename(dump.initdata_path)))
            if dump.has_card_id:
                files_to_copy.append((dump.cardid_path, os.path.basename(dump.cardid_path)))
            if dump.has_card_uid:
                files_to_copy.append((dump.carduid_path, os.path.basename(dump.carduid_path)))
        
        # Calculate total size
        total_size = sum(os.path.getsize(src) for src, _ in files_to_copy)
        copied = 0
        
        for src_path, filename in files_to_copy:
            dest_path = os.path.join(dest_dir, filename)
            
            self._report_progress(copied, total_size, f"Copying {filename}")
            
            if not self._copy_file_with_progress(src_path, dest_path, 
                                                  copied, total_size):
                return False
            
            copied += os.path.getsize(src_path)
        
        self._report_progress(total_size, total_size, "Complete")
        return True
    
    def _copy_file_with_progress(self, src: str, dst: str,
                                  offset: int, total: int) -> bool:
        """Copy file with progress reporting"""
        
        buffer_size = 4 * 1024 * 1024  # 4 MB
        
        try:
            src_size = os.path.getsize(src)
            
            with open(src, 'rb') as fsrc, open(dst, 'wb') as fdst:
                copied = 0
                
                while True:
                    data = fsrc.read(buffer_size)
                    if not data:
                        break
                    
                    fdst.write(data)
                    copied += len(data)
                    
                    self._report_progress(offset + copied, total, 
                                         os.path.basename(src))
            
            return True
        
        except OSError as e:
            print(f"Error copying {src}: {e}")
            return False
    
    def delete_dump(self, dump: DumpInfo) -> bool:
        """Delete a dump from MIG Dumper"""
        
        if os.path.isdir(dump.path):
            try:
                shutil.rmtree(dump.path)
                return True
            except OSError as e:
                print(f"Error deleting {dump.path}: {e}")
                return False
        else:
            try:
                os.remove(dump.path)
                return True
            except OSError as e:
                print(f"Error deleting {dump.path}: {e}")
                return False
    
    # ========================================================================
    # Verification
    # ========================================================================
    
    def verify_dump(self, dump: DumpInfo) -> Dict[str, any]:
        """Verify dump integrity"""
        
        result = {
            'valid': True,
            'header_valid': False,
            'size_valid': False,
            'certificate_present': False,
            'sha256': None,
            'errors': []
        }
        
        try:
            # Read and verify header
            with open(dump.xci_path, 'rb') as f:
                header_data = f.read(0x200)
            
            try:
                header = XCIHeader.from_bytes(header_data)
                result['header_valid'] = True
            except ValueError as e:
                result['errors'].append(f"Invalid header: {e}")
                result['valid'] = False
            
            # Check file size
            file_size = os.path.getsize(dump.xci_path)
            expected_size = header.get_data_size() if result['header_valid'] else 0
            
            if file_size >= expected_size:
                result['size_valid'] = True
            else:
                result['errors'].append(
                    f"File size {file_size} < expected {expected_size}")
                result['valid'] = False
            
            # Check certificate area
            if result['header_valid']:
                with open(dump.xci_path, 'rb') as f:
                    f.seek(XCI_CERT_OFFSET)
                    cert_data = f.read(0x200)
                
                # Certificate should be either valid data or 0xFF (blanked)
                if cert_data == b'\xFF' * 0x200:
                    result['certificate_present'] = False
                else:
                    result['certificate_present'] = True
            
            # Calculate SHA256 (optional, slow for large files)
            # result['sha256'] = self._calculate_sha256(dump.xci_path)
        
        except OSError as e:
            result['errors'].append(f"Read error: {e}")
            result['valid'] = False
        
        return result
    
    def _calculate_sha256(self, path: str) -> str:
        """Calculate SHA256 hash of file"""
        
        sha256 = hashlib.sha256()
        file_size = os.path.getsize(path)
        processed = 0
        
        with open(path, 'rb') as f:
            while True:
                data = f.read(4 * 1024 * 1024)
                if not data:
                    break
                sha256.update(data)
                processed += len(data)
                self._report_progress(processed, file_size, "Calculating SHA256")
        
        return sha256.hexdigest()


# ============================================================================
# CLI Interface
# ============================================================================

def cmd_detect(args):
    """Detect MIG Dumper device"""
    manager = MIGDumperManager(args.mount_point)
    device = manager.detect_device()
    
    if device:
        print(f"MIG Dumper detected:")
        print(f"  Device: {device.device_path}")
        print(f"  Mounted: {device.is_mounted}")
        if device.is_mounted:
            print(f"  Mount point: {device.mount_point}")
            print(f"  Firmware: {device.firmware_version}")
            print(f"  Total space: {device.total_space / (1024**3):.1f} GB")
            print(f"  Free space: {device.free_space / (1024**3):.1f} GB")
        return 0
    else:
        print("No MIG Dumper detected")
        return 1


def cmd_mount(args):
    """Mount MIG Dumper"""
    manager = MIGDumperManager(args.mount_point)
    
    if manager.mount(args.device):
        print("Mount successful")
        return 0
    else:
        print("Mount failed")
        return 1


def cmd_unmount(args):
    """Unmount MIG Dumper"""
    manager = MIGDumperManager(args.mount_point)
    
    if manager.unmount():
        print("Unmount successful")
        return 0
    else:
        print("Unmount failed")
        return 1


def cmd_list(args):
    """List dumps on MIG Dumper"""
    manager = MIGDumperManager(args.mount_point)
    
    if not manager.mount():
        return 1
    
    dumps = manager.list_dumps()
    
    if not dumps:
        print("No dumps found")
        return 0
    
    print(f"Found {len(dumps)} dump(s):\n")
    
    for i, dump in enumerate(dumps, 1):
        print(f"{i}. {dump.title}")
        if dump.title_id:
            print(f"   Title ID: {dump.title_id}")
        print(f"   ROM Size: {dump.rom_size_gb} GB")
        print(f"   File Size: {dump.file_size / (1024**3):.2f} GB")
        if dump.trimmed_size < dump.file_size:
            print(f"   Trimmed Size: {dump.trimmed_size / (1024**3):.2f} GB")
        if dump.dump_date:
            print(f"   Date: {dump.dump_date.strftime('%Y-%m-%d %H:%M')}")
        
        extras = []
        if dump.has_certificate:
            extras.append("Certificate")
        if dump.has_initial_data:
            extras.append("Initial Data")
        if dump.has_card_id:
            extras.append("Card ID")
        if dump.has_card_uid:
            extras.append("Card UID")
        
        if extras:
            print(f"   Extras: {', '.join(extras)}")
        print()
    
    return 0


def progress_callback(current: int, total: int, percent: int, message: str):
    """Progress callback for copy operations"""
    bar_width = 40
    filled = int(bar_width * percent / 100)
    bar = '█' * filled + '░' * (bar_width - filled)
    
    speed_mb = current / (1024 * 1024)
    total_mb = total / (1024 * 1024)
    
    print(f"\r[{bar}] {percent}% ({speed_mb:.0f}/{total_mb:.0f} MB) {message[:30]:30s}", 
          end='', flush=True)


def cmd_copy(args):
    """Copy dump from MIG Dumper"""
    manager = MIGDumperManager(args.mount_point)
    manager.set_progress_callback(progress_callback)
    
    if not manager.mount():
        return 1
    
    dumps = manager.list_dumps()
    
    if not dumps:
        print("No dumps found")
        return 1
    
    # Find matching dump
    target = None
    
    if args.index:
        if 1 <= args.index <= len(dumps):
            target = dumps[args.index - 1]
    elif args.title:
        for dump in dumps:
            if args.title.lower() in dump.title.lower():
                target = dump
                break
    else:
        # Interactive selection
        print("Select dump to copy:")
        for i, dump in enumerate(dumps, 1):
            print(f"  {i}. {dump.title} ({dump.file_size / (1024**3):.2f} GB)")
        
        try:
            choice = int(input("\nEnter number: "))
            if 1 <= choice <= len(dumps):
                target = dumps[choice - 1]
        except (ValueError, EOFError):
            pass
    
    if not target:
        print("No dump selected")
        return 1
    
    dest_dir = args.output or UFI_IMAGES_DIR
    
    print(f"\nCopying: {target.title}")
    print(f"To: {dest_dir}")
    print()
    
    if manager.copy_dump(target, dest_dir, include_extras=not args.xci_only):
        print("\n\nCopy complete!")
        return 0
    else:
        print("\n\nCopy failed!")
        return 1


def cmd_verify(args):
    """Verify dump integrity"""
    manager = MIGDumperManager(args.mount_point)
    
    if not manager.mount():
        return 1
    
    dumps = manager.list_dumps()
    
    if not dumps:
        print("No dumps found")
        return 1
    
    # Find matching dump
    target = None
    
    if args.index:
        if 1 <= args.index <= len(dumps):
            target = dumps[args.index - 1]
    else:
        target = dumps[0]  # Default to first
    
    if not target:
        print("No dump selected")
        return 1
    
    print(f"Verifying: {target.title}")
    
    result = manager.verify_dump(target)
    
    print(f"\nResults:")
    print(f"  Header valid: {'Yes' if result['header_valid'] else 'No'}")
    print(f"  Size valid: {'Yes' if result['size_valid'] else 'No'}")
    print(f"  Certificate in XCI: {'Yes' if result['certificate_present'] else 'No (blanked)'}")
    
    if result['errors']:
        print(f"\nErrors:")
        for error in result['errors']:
            print(f"  - {error}")
    
    return 0 if result['valid'] else 1


def cmd_delete(args):
    """Delete dump from MIG Dumper"""
    manager = MIGDumperManager(args.mount_point)
    
    if not manager.mount():
        return 1
    
    dumps = manager.list_dumps()
    
    if not dumps:
        print("No dumps found")
        return 1
    
    # Find matching dump
    target = None
    
    if args.index:
        if 1 <= args.index <= len(dumps):
            target = dumps[args.index - 1]
    
    if not target:
        print("No dump selected")
        return 1
    
    print(f"Delete: {target.title}")
    print(f"Path: {target.path}")
    
    if not args.force:
        confirm = input("\nAre you sure? (yes/no): ")
        if confirm.lower() != 'yes':
            print("Cancelled")
            return 0
    
    if manager.delete_dump(target):
        print("Deleted successfully")
        return 0
    else:
        print("Delete failed")
        return 1


def main():
    parser = argparse.ArgumentParser(
        description="UFI MIG Dumper Integration Tool",
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    
    parser.add_argument('--version', action='version', version=f'%(prog)s {VERSION}')
    parser.add_argument('-m', '--mount-point', default=MIG_MOUNT_POINT,
                        help=f'Mount point (default: {MIG_MOUNT_POINT})')
    
    subparsers = parser.add_subparsers(dest='command', help='Commands')
    
    # Detect command
    detect_parser = subparsers.add_parser('detect', help='Detect MIG Dumper')
    detect_parser.set_defaults(func=cmd_detect)
    
    # Mount command
    mount_parser = subparsers.add_parser('mount', help='Mount MIG Dumper')
    mount_parser.add_argument('-d', '--device', help='Device path (auto-detect if not specified)')
    mount_parser.set_defaults(func=cmd_mount)
    
    # Unmount command
    unmount_parser = subparsers.add_parser('unmount', help='Unmount MIG Dumper')
    unmount_parser.set_defaults(func=cmd_unmount)
    
    # List command
    list_parser = subparsers.add_parser('list', help='List dumps')
    list_parser.set_defaults(func=cmd_list)
    
    # Copy command
    copy_parser = subparsers.add_parser('copy', help='Copy dump to UFI')
    copy_parser.add_argument('-i', '--index', type=int, help='Dump index (from list)')
    copy_parser.add_argument('-t', '--title', help='Search by title')
    copy_parser.add_argument('-o', '--output', help=f'Output directory (default: {UFI_IMAGES_DIR})')
    copy_parser.add_argument('--xci-only', action='store_true', 
                             help='Copy only XCI file (skip extras)')
    copy_parser.set_defaults(func=cmd_copy)
    
    # Verify command
    verify_parser = subparsers.add_parser('verify', help='Verify dump')
    verify_parser.add_argument('-i', '--index', type=int, help='Dump index')
    verify_parser.set_defaults(func=cmd_verify)
    
    # Delete command
    delete_parser = subparsers.add_parser('delete', help='Delete dump')
    delete_parser.add_argument('-i', '--index', type=int, required=True, help='Dump index')
    delete_parser.add_argument('-f', '--force', action='store_true', help='Skip confirmation')
    delete_parser.set_defaults(func=cmd_delete)
    
    args = parser.parse_args()
    
    if not args.command:
        parser.print_help()
        return 1
    
    return args.func(args)


if __name__ == '__main__':
    sys.exit(main())
